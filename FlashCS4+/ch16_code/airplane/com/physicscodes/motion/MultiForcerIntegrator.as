package com.physicscodes.motion {	import com.physicscodes.motion.Mover;	import com.physicscodes.objects.Particle;			import com.physicscodes.math.Vector2D;	public class MultiForcerIntegrator extends Mover{				private var _particles:Array;		private var _force:Vector2D;		private var _acc:Vector2D;	//		private var _oldpos:Vector2D; 	// needed for Standard Verlet scheme		private var _oldpos:Array = new Array(); 	// needed for Standard Verlet scheme		private var _olddt:Number;		// as above		private var _n:uint=0;			// as above				public function MultiForcerIntegrator(pparticles:Array):void{			_particles = pparticles;			super(null);		}					public function get force():Vector2D {			return _force;		}							public function set force(pforce):void {			_force = pforce;		}						protected function calcForce(pparticle:Particle,pnum:uint,ppos:Vector2D,pvel:Vector2D):void{			_force = Forces.zeroForce();		}				private function getAcc(pparticle:Particle,pnum:uint,ppos:Vector2D,pvel:Vector2D):Vector2D{			calcForce(pparticle,pnum,ppos,pvel);			return _force.multiply(1/pparticle.mass);		}		override protected function moveObject():void{			for (var i:uint=0; i<_particles.length; i++){				var particle:Particle = _particles[i];				// choose one scheme; comment out the rest				//EulerExplicit(particle,i);				//EulerSemiImplicit(particle,i);				//EulerSemiImplicit2(particle,i);				//RK2(particle,i);				//RK4(particle,i);							PositionVerlet(particle,i);				//VelocityVerlet(particle,i);													}		}				override protected function spinObject():void{			for (var i:uint=0; i<_particles.length; i++){				var particle:Particle = _particles[i];				if (particle.angVelo !=0){					particle.rotation += particle.angVelo*dt*180/Math.PI; 				}														}					}				private function EulerExplicit(pparticle:Particle,pnum:uint):void{						_acc = getAcc(pparticle,pnum,pparticle.pos2D,pparticle.velo2D); 			pparticle.pos2D = pparticle.pos2D.addScaled(pparticle.velo2D,dt);			pparticle.velo2D = pparticle.velo2D.addScaled(_acc,dt);					}				private function EulerSemiImplicit(pparticle:Particle,pnum:uint):void{						_acc = getAcc(pparticle,pnum,pparticle.pos2D,pparticle.velo2D); 			pparticle.velo2D = pparticle.velo2D.addScaled(_acc,dt);						pparticle.pos2D = pparticle.pos2D.addScaled(pparticle.velo2D,dt);					}				private function EulerSemiImplicit2(pparticle:Particle,pnum:uint):void{						pparticle.pos2D = pparticle.pos2D.addScaled(pparticle.velo2D,dt);								_acc = getAcc(pparticle,pnum,pparticle.pos2D,pparticle.velo2D); 			pparticle.velo2D = pparticle.velo2D.addScaled(_acc,dt);					}						private function PositionVerlet(pparticle:Particle,pnum:uint):void{						var temp:Vector2D = pparticle.pos2D; // store current position in temp variable			if (_n==0){ // initialize old position and old timestep				_acc = getAcc(pparticle,pnum,pparticle.pos2D,pparticle.velo2D); 				_oldpos[pnum] = pparticle.pos2D.addScaled(pparticle.velo2D,-dt).addScaled(_acc,dt*dt/2);				_olddt = dt;			}			_acc = getAcc(pparticle,pnum,pparticle.pos2D,pparticle.velo2D); // acceleration based on current pos and velo			pparticle.pos2D = pparticle.pos2D.addScaled(pparticle.pos2D.subtract(_oldpos[pnum]),dt/_olddt).addScaled(_acc,dt*dt); // update pos			pparticle.velo2D = (pparticle.pos2D.subtract(_oldpos[pnum])).multiply(0.5/dt);	// estimate new velocity								_oldpos[pnum] = temp; // store pos before update; will be pos at previous timestep next time			if (pnum==_particles.length-1){				_olddt = dt;				_n++;			}		}						private function VelocityVerlet(pparticle:Particle,pnum:uint):void{						_acc = getAcc(pparticle,pnum,pparticle.pos2D,pparticle.velo2D); // acceleration based on current pos and velo			var accPrev:Vector2D = _acc; // save for velo update calculation			pparticle.pos2D = pparticle.pos2D.addScaled(pparticle.velo2D,dt).addScaled(_acc,dt*dt/2); // update pos			_acc = getAcc(pparticle,pnum,pparticle.pos2D,pparticle.velo2D); // acceleration based on updated pos; note assume force does not depend explicitly on velo			pparticle.velo2D = pparticle.velo2D.addScaled(_acc.add(accPrev),dt/2);	//update velocity				}				private function RK2(pparticle:Particle,pnum:uint):void{						// step 1			var pos1:Vector2D = pparticle.pos2D;			var vel1:Vector2D = pparticle.velo2D;			var acc1:Vector2D = getAcc(pparticle,pnum,pos1,vel1); 			// step 2			var pos2:Vector2D = pos1.addScaled(vel1,dt); 			var vel2:Vector2D = vel1.addScaled(acc1,dt);			var acc2:Vector2D = getAcc(pparticle,pnum,pos2,vel2); 			// update particle pos and velo			pparticle.pos2D = pos1.addScaled(vel1.add(vel2),dt/2);			pparticle.velo2D = vel1.addScaled(acc1.add(acc2),dt/2);						//_acc = acc1.add(acc2).multiply(1/2); 			 		}		private function RK4(pparticle:Particle,pnum:uint):void{						// step 1			var pos1:Vector2D = pparticle.pos2D;			var vel1:Vector2D = pparticle.velo2D;			var acc1:Vector2D = getAcc(pparticle,pnum,pos1,vel1); 			// step 2			var pos2:Vector2D = pos1.addScaled(vel1,dt/2); 			var vel2:Vector2D = vel1.addScaled(acc1,dt/2);			var acc2:Vector2D = getAcc(pparticle,pnum,pos2,vel2); 			// step 3			var pos3:Vector2D = pos1.addScaled(vel2,dt/2); 			var vel3:Vector2D = vel1.addScaled(acc2,dt/2);			var acc3:Vector2D = getAcc(pparticle,pnum,pos3,vel3); 			// step 4			var pos4:Vector2D = pos1.addScaled(vel3,dt); 			var vel4:Vector2D = vel1.addScaled(acc3,dt);			var acc4:Vector2D = getAcc(pparticle,pnum,pos4,vel4); 			// sum vel and acc			var velsum:Vector2D = vel1.addScaled(vel2,2).addScaled(vel3,2).add(vel4);			var accsum:Vector2D = acc1.addScaled(acc2,2).addScaled(acc3,2).add(acc4);			// update particle pos and velo			pparticle.pos2D = pos1.addScaled(velsum,dt/6);			pparticle.velo2D = vel1.addScaled(accsum,dt/6);						//_acc = accsum.multiply(1/6);		}						}	}