package com.physicscodes.motion{	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	import flash.geom.Vector3D;	import com.physicscodes.objects.Particle3D;		public class Mover3D {		private var _particle:Particle3D;		private var _time:Number;		private var _t0:Number;		private var _dt:Number;		private var _timer:Timer;			public function Mover3D(pparticle:Particle3D):void {			_particle = pparticle;		}		// THIS FUNCTION IS CALLED EXTERNALLY TO INITIATE THE TIMER AND EVENT LISTENER		public function startTime(ptimestep:Number=20,psteps:Number=0):void {			_timer=new Timer(ptimestep,psteps);			_timer.addEventListener(TimerEvent.TIMER,onTimer);			_timer.start();			_time = 0;			_t0 = getTimer();		}		public function stopTime():void {			_timer.removeEventListener(TimerEvent.TIMER,onTimer);			_timer.stop();		}		public function killTime():void {			stopTime();			if (_timer && _timer.running) _timer.stop();			_timer=null;					}		public function get time():Number {			return _time;		}		public function get dt():Number {			return _dt;		}				// THIS FUNCTION IS CALLED UPON EVERY TIMER EVENT; IT DOES THE TIME-STEPPING		private function onTimer(pEvent:TimerEvent):void {			_dt = 0.001 * (getTimer() - _t0);			_time += _dt;			_t0  =getTimer();			moveObject();			//spinObject();			pEvent.updateAfterEvent();								}		protected function moveObject():void {			var vec:Vector3D = _particle.velo;			vec.scaleBy(_dt);			_particle.pos = _particle.pos.add(vec);		}				// note that we are getting rid of spinObject() because we'll apply rotations in a different way/*				protected function spinObject():void{			if (_particle.angVelo.length !=0){				var vec:Vector3D = _particle.angVelo;				vec.scaleBy(_dt);				_particle.angDispl = _particle.angDispl.add(vec);			}		}*/			}}