package com.physicscodes.motion{	import flash.geom.Vector3D;		public class Forces3D {		public function Forces3D():void {		}		static public function zeroForce():Vector3D {			return (new Vector3D(0,0,0));		}		static public function constantGravity(m:Number,g:Number):Vector3D {			return new Vector3D(0,m*g,0);		}		static public function gravity(G:Number,m1:Number,m2:Number,r:Vector3D):Vector3D {			var vec:Vector3D = r;			vec.scaleBy(-G*m1*m2/(r.lengthSquared*r.length));			return vec;		}			static public function electric(k:Number,q1:Number,q2:Number,r:Vector3D):Vector3D {			var vec:Vector3D = r;			vec.scaleBy(k*q1*q2/(r.lengthSquared*r.length));			return vec;		}				static public function forceField(q:Number,E:Vector3D):Vector3D {			var vec:Vector3D = E;			vec.scaleBy(q);			return vec;		}			static public function central(k:Number,n:Number,r:Vector3D):Vector3D {			var vec:Vector3D = r;			vec.scaleBy(k*Math.pow(r.length,n-1));			return vec;					}				static public function linearDrag(k:Number,vel:Vector3D):Vector3D {			var force:Vector3D;			var vec:Vector3D = vel;			var velMag:Number=vel.length;			vec.scaleBy(-k);									if (velMag>0) {				force=vec;			}			else {				force=new Vector3D(0,0,0);			}			return force;		}		static public function drag(k:Number,vel:Vector3D):Vector3D {			var force:Vector3D;			var vec:Vector3D = vel;							var velMag:Number=vel.length;			vec.scaleBy(-k*velMag);								if (velMag>0) {				force=vec;			}			else {				force=new Vector3D(0,0,0);			}			return force;					}		static public function lift(k:Number,vel:Vector3D):Vector3D {			var force:Vector3D;			var velMag:Number=vel.length;			if (velMag>0) {				// need to get the lift force in vector form	//			force=vel.perp(k*velMag);			}			else {				force=new Vector3D(0,0,0);			}			return force;					}					static public function upthrust(rho:Number,V:Number,g:Number):Vector3D {			return new Vector3D(0,-rho*V*g,0);		}			static public function spring(k:Number,r:Vector3D):Vector3D {			var vec:Vector3D = r;			vec.scaleBy(-k);				return vec;		}				static public function damping(c:Number,vel:Vector3D):Vector3D {			var force:Vector3D;			var vec:Vector3D = vel;			var velMag:Number=vel.length;			vec.scaleBy(-c);			if (velMag>0) {				force=vec;			}			else {				force=new Vector3D(0,0,0);			}			return force;		}								static public function add(arr:Array):Vector3D {			var forceSum:Vector3D = new Vector3D(0,0,0);			for (var i:uint=0; i<arr.length; i++){				var force:Vector3D = arr[i];				forceSum.incrementBy(force);			}			return forceSum;		}	}}