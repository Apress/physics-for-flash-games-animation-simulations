package {	import com.physicscodes.motion.MultiForcer2;	import com.physicscodes.motion.Forces;	import com.physicscodes.objects.Ball;	import com.physicscodes.objects.Particle;		import com.physicscodes.math.Vector2D;	import flash.display.Sprite;	import flash.events.MouseEvent;			public class ClothMover extends MultiForcer2{		private var _objects:Array;		private var _displ:Vector2D;		private var _g:Number=10;		private var _kDamping:Number=10;		private var _kSpring:Number=100;		private var _kWind:Number=10;		private var _springLength:Number=20;		private var _windMag:Number=10;				private var _w:Number=0;		private var _fixedPoints:Array;				private var _nrows:uint;		private var _ncols:uint;				private var _spring:Sprite;				public function ClothMover(pobjects:Array,pfixedPoints,pcols:uint,prows:uint,pspring:Sprite):void{			_objects = pobjects;			_fixedPoints = pfixedPoints;			_ncols = pcols;			_nrows = prows;						_spring = pspring;			_spring.stage.addEventListener(MouseEvent.MOUSE_DOWN,onDown);										super(_objects);		}				override protected function moveObject():void{			super.moveObject();			drawSpring();					}				override protected function calcForce(pparticle:Particle,pnum:uint):void{			// variables to store positions and velocities of nearest neighbors			var centerUp:Vector2D;			var centerDown:Vector2D;			var centerLeft:Vector2D;			var centerRight:Vector2D;			var veloUp:Vector2D;			var veloDown:Vector2D;			var veloLeft:Vector2D;			var veloRight:Vector2D;									// position and velocity of particle above current particle						if ((pnum-Math.floor(pnum/_nrows)*_nrows) > 0){				centerUp = _objects[pnum-1].pos2D;				veloUp = _objects[pnum-1].velo2D;							}else{ // current particle is in first row, no particle above, just use current particle's position and velocity 				centerUp= pparticle.pos2D;				veloUp= pparticle.velo2D;							}			// position and velocity of particle below current particle									if ( ((pnum+1)-Math.floor( (pnum+1)/_nrows) * _nrows) > 0){				centerDown = _objects[pnum+1].pos2D;				veloDown = _objects[pnum+1].velo2D;							}else{ // current particle is in last row, no particle below, just use current particle's position and velocity 				centerDown= pparticle.pos2D;				veloDown= pparticle.velo2D;							}			// position and velocity of particle to the left of current particle						if (pnum > (_nrows-1) ){				centerLeft = _objects[pnum-_nrows].pos2D;				veloLeft = _objects[pnum-_nrows].velo2D;			}else{ // current particle is in first column, no particle to the left, just use current particle's position and velocity 				centerLeft= pparticle.pos2D;				veloLeft= pparticle.velo2D;							}			// position and velocity of particle to the right of current particle						if (pnum < _nrows*(_ncols -1) ) {				centerRight = _objects[pnum+_nrows].pos2D;				veloRight = _objects[pnum+_nrows].velo2D;			}else{  // current particle is in last column, no particle to the right, just use current particle's position and velocity 				centerRight= pparticle.pos2D;				veloRight= pparticle.velo2D;			}						// apply gravity to all particles (except fixed ones)			var gravity:Vector2D = Forces.constantGravity(pparticle.mass,_g);//			var damping:Vector2D = Forces.damping(_kDamping,pparticle.velo2D);						// damping force 			var velo:Vector2D = pparticle.velo2D.multiply(4).subtract(veloUp).subtract(veloDown).subtract(veloLeft).subtract(veloRight);			var damping:Vector2D = Forces.damping(_kDamping,velo);							// displacement vector of current particle from each of its nearest neighbours			var displUp:Vector2D = pparticle.pos2D.subtract(centerUp);			var displDown:Vector2D = pparticle.pos2D.subtract(centerDown);						var displLeft:Vector2D = pparticle.pos2D.subtract(centerLeft);			var displRight:Vector2D = pparticle.pos2D.subtract(centerRight);						// extension vector of current particle from equilibrium position with respect to each neighbour			var extensionUp:Vector2D = displUp.subtract(displUp.unit().multiply(_springLength));			var extensionDown:Vector2D = displDown.subtract(displDown.unit().multiply(_springLength));				var extensionLeft:Vector2D = displLeft.subtract(displLeft.unit().multiply(_springLength));			var extensionRight:Vector2D = displRight.subtract(displRight.unit().multiply(_springLength));				// spring force exerted by each neighbour on the current particle			var restoringUp:Vector2D = Forces.spring(_kSpring,extensionUp);			var restoringDown:Vector2D = Forces.spring(_kSpring,extensionDown);												var restoringLeft:Vector2D = Forces.spring(_kSpring,extensionLeft);			var restoringRight:Vector2D = Forces.spring(_kSpring,extensionRight);												// external wind velocity and resulting wind force			var windVelocity:Vector2D = new Vector2D(_w,0);			var windForce:Vector2D = Forces.linearDrag((-1)*_kWind,windVelocity.subtract(pparticle.velo2D));			// identify fixed particles			var fixed:Boolean = false;			for (var i:uint=0; i<_fixedPoints.length; i++){				if (pnum==_fixedPoints[i]){					fixed = true;				}			}			// apply forces to all particles that are not fixed			if (!fixed){ 				force = Forces.add([gravity, damping, restoringUp, restoringDown,restoringLeft, restoringRight, windForce]);			}else{ // zero force on fixed particles				force=new Vector2D(0,0);			}		}							// function to draw lines connecting neighboring particles		private function drawSpring():void{			with (_spring.graphics){				clear();						lineStyle(2,0x009999);				for (var i:uint=0; i<(_nrows*_ncols); i++){ 					var X:Number = _objects[i].xpos;					var Y:Number = _objects[i].ypos;					if((i-Math.floor(i/_nrows)*_nrows) ==0) {					moveTo(X,Y);					}					else{					lineTo(X,Y);					}				}				for (i=0; i<(_nrows); i++){					X = _objects[i].xpos;					Y = _objects[i].ypos;					moveTo(X,Y);					for (var j:uint=0; j<(_ncols); j++){					X= _objects[i+j*_nrows].xpos;					Y = _objects[i+j*_nrows].ypos;					lineTo(X,Y);					}				}			}		}				private function onDown(e:MouseEvent):void{			_spring.stage.addEventListener(MouseEvent.MOUSE_UP,onUp);			_w = _windMag;		}		private function onUp(e:MouseEvent):void{			_spring.stage.removeEventListener(MouseEvent.MOUSE_UP,onUp);			_w = 0;		}								}}