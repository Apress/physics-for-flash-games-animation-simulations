package {	import com.physicscodes.motion.Forcer;	import com.physicscodes.motion.Forces;	import com.physicscodes.objects.Ball;	import com.physicscodes.objects.Wall;	import com.physicscodes.math.Vector2D;	import flash.events.Event;	import flash.events.MouseEvent;				public class MultipleInclinedWallsBouncer extends Forcer{		private var _ball:Ball;		private var _walls:Array;		private var _g:Number=50;		//private var _vfac:Number=0.8;		private var _vfac:Number=1;						public function MultipleInclinedWallsBouncer(object:Ball, walls:Array) :void{			_ball = object;						_walls = walls;			_ball.stage.addEventListener(MouseEvent.MOUSE_DOWN,onDown);									super(_ball);		}				private function onDown(e:MouseEvent):void{			_ball.velo2D = new Vector2D(0,0);			_ball.stage.addEventListener(MouseEvent.MOUSE_UP,onUp);			_ball.radius = 1;					_ball.xpos = _ball.stage.mouseX;			_ball.ypos = _ball.stage.mouseY;				_ball.stage.addEventListener(Event.ENTER_FRAME,onEachFrame); 			stopTime();					}		private function onUp(e:MouseEvent):void{			_ball.stage.removeEventListener(MouseEvent.MOUSE_UP,onUp);			_ball.stage.removeEventListener(Event.ENTER_FRAME,onEachFrame); 						startTime();					}						private function onEachFrame(e:Event):void{			var dvec:Vector2D = new Vector2D(_ball.stage.mouseX-_ball.xpos,_ball.stage.mouseY-_ball.ypos);			_ball.radius = dvec.length;					}				override protected function moveObject():void{			super.moveObject();			checkBounce();		}			override protected function calcForce():void{			force = Forces.constantGravity(_ball.mass,_g);		}		private function checkBounce():void{							var hasHitAWall:Boolean = false;					for (var i:int=0; (i<_walls.length && hasHitAWall==false); i++){				var wall:Wall = _walls[i];							var wdir:Vector2D = wall.dir;			   		    	var ballp1:Vector2D = wall.p1.subtract(_ball.pos2D);				var ballp2:Vector2D = wall.p2.subtract(_ball.pos2D);				var proj1:Number = ballp1.projection(wdir);                				var proj2:Number = ballp2.projection(wdir);				var dist:Vector2D = ballp1.addScaled(wdir.unit(), proj1*(-1));				var test:Boolean=((Math.abs(proj1) < wdir.length) && (Math.abs(proj2) < wdir.length));				if ((dist.length < _ball.radius) &&  test){					var angle:Number = Vector2D.angleBetween(_ball.velo2D, wdir);					var normal:Vector2D = wall.normal;					if (normal.dotProduct(_ball.velo2D) > 0){						normal.scaleBy(-1);					}					var deltaS:Number = (_ball.radius+dist.dotProduct(normal))/Math.sin(angle);					var displ:Vector2D = _ball.velo2D.para(deltaS);					_ball.pos2D = _ball.pos2D.subtract(displ);								var vcor:Number = 1-acc.dotProduct(displ)/_ball.velo2D.lengthSquared;					var Velo:Vector2D = _ball.velo2D.multiply(vcor);					var normalVelo:Vector2D = dist.para(Velo.projection(dist));					var tangentVelo:Vector2D = Velo.subtract(normalVelo);					_ball.velo2D = tangentVelo.addScaled(normalVelo,-_vfac);										hasHitAWall = true;			   	}				else if (Math.abs(ballp1.length) < _ball.radius){					bounceOffEndpoint(wall.p1);					hasHitAWall = true;				}				else if (Math.abs(ballp2.length) < _ball.radius){					bounceOffEndpoint(wall.p2);					hasHitAWall = true;				}							}					}			private function bounceOffEndpoint(pEndpoint:Vector2D):void{			var distp:Vector2D = _ball.pos2D.subtract(pEndpoint);			// move particle so that it just touches the endpoint						var L:Number = _ball.radius-distp.length;			var vrel:Number = _ball.velo2D.length;			_ball.pos2D = _ball.pos2D.addScaled(_ball.velo2D,-L/vrel);			// normal velocity vector just before the impact			var normalVelo:Vector2D = _ball.velo2D.project(distp);			// tangential velocity vector			var tangentVelo:Vector2D = _ball.velo2D.subtract(normalVelo);			// normal velocity vector after collision			normalVelo.scaleBy(-_vfac);			// final velocity vector after collision			_ball.velo2D = normalVelo.add(tangentVelo);					}			}}